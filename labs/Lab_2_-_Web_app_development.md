# Lab 2 - Web app development (Server-side)
You will be developing a Web-based application in your project (using *TypeScript* and the *WebStorm* IDE, which have been introduced in the last lab). If we want to build a Web-based application, we need an engine to run server-side code. Since we will use TypeScript for developing server-side *and* client-side code, we need an engine that can execute TypeScript (transpiled to JavaScript) on the server. (The client-side code is obviously executed in the client’s browser.)

Various execution engines exist for server-side JavaScript, including [Node.js](https://nodejs.org/en/), which we will use in our project. Node is often used together with the [Express.js](https://expressjs.com) web framework, which facilitates many aspects of Web application programming. Other useful modules are also available, such as the [Pug](https://pugjs.org/api/getting-started.html) (formerly known as Jade) library for template-based generation of HTML pages.

In this lab, you will learn how to set up a Web application development project, using TypeScript, WebStorm and Node.


## Step 1: Create the project

You can use WebStorm to create a Node.js/Express project. (Note: WebStorm just uses the express-generator script, which can also be invoked from the command line.)

![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533251491520_image.png)


The generated new project will contain a [*package.json*](https://docs.npmjs.com/files/package.json) file which contains the configuration of the Node.js project. Have a look at the file to see what it contains.


![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533252322239_image.png)


We see that the *package.json* file contains information about the location of the start script. (It’s in the directory *bin* and called *www*.) A boilerplate version of that file was also generated for us. Let’s open it and look inside.






![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533252961200_image.png)


The beginning of the start script requires dependencies (our generated app) and the http module. The script then determines the port for the Web server (either from the environment or it is set to 3000.) The script then creates the server and tells it to listen on the specific port. It also registers event handlers (which are defined in the rest of the file).












A boilerplate JavaScript app was also created (app.js). However, we don’t care about this one, since we will be writing our application in TypeScript and the JavaScript files will be generated by the TypeScript compiler tsc. **So, let’s delete app.js** using WebStorm. Note that the IDE is warning you that the file is being used and that it may be unsafe to delete it. If you use the IDE to view the code that “uses” app.js, you will indeed find that the www script loads it. Go ahead and delete it anyway. We will be placing our JavaScript generated code in a different directory in any case.

Let’s initialize a new TypeScript project with “tsc —init” (see last lab where terminal is, click on it and enter the tsc command (alternatively, under project (right click then New → tsconfig.json))). This will create the TypeScript configuration file “*tsconfig.json”*. 


![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533324264971_image.png)


Now let’s create a directory “*src*” for our TypeScript source code and a “dist” directory for our compiled output (JavaScript etc.). Your directory structure should now look like the one on the right.

 







![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533324545433_image.png)


Now we edit the tsconfig file again (like in the last lab) to tell the tsc compiler where our TypeScript sources will be, where to place the JavaScript output, and to include the source maps for debugging. The important properties are listed in the left.




## Step 2: Create a TypeScript Server class

Let us now create a first TypeScript server class for our app (in the source folder). You can use the IDE to create this file (see screenshot below). Let’s call the file “app”. (Like in the last lab, the IDE will offer to automatically compile the TypeScript. Click on “yes”.)

![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533324714140_image.png)


[Here](https://paper.dropbox.com/doc/Boilerplate-code-for-Server-class--ALVhDOiZuFqmYSFGpZ9XyiY1Ag-xboDpcniAGLinsdDwAoZI) is a boilerplate code our newly created TypeScript class. Go ahead and copy it into the newly generated file. The code starts by importing middleware and necessary modules. 

![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533326780518_image.png)

    - The *body-parser* middleware will parse JSON payload data into the `req.body` object that will be available in our express application.
    - The *cookie-parser* middleware is similar to the *body-parser* in that it parses the user’s cookie data and makes this available in the `req.cookies` object.
    - We then import the *express* module. This is the Express framework.
    - We are also making use of the *morgan* HTTP logger middleware. This should only be used during development.
    - We also import the *path* module. This will be used to set the path directories for **public** and **views** directories in the `config()` method.
    - The *errorhandler* middleware will handle errors during development. Again, this should not be used in production. Rather, you will want to log your errors and then show the user a error indication.
    - Finally, we import the TypeScript module that implements our first route (the index route). (If you are unfamiliar with the term “*routing”*  in Web applications you may want to read [this](https://expressjs.com/en/starter/basic-routing.html). Essentially, routes define endpoints (paths) for a web application, as identified by different URIs. Routes are defined in terms of TypeScript classes. More about this later.)
    
![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533326882398_image.png)


Next we have a new class called `Server`. Our class has a single publicly available variable named `app`. Note that our app is of type `express.Application`.
Inside the `Server` class I have a static method named `bootstrap()`. This will be invoked in our **www** startup script. (We will need to change that script.) It simply creates a new instance of the `Server` class and returns it.


![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1535486511993_image.png)


The `constructor()` function sets the value of the `app` property by creating a new express application. We are then calling some methods that are defined in the `Server` class to configure the application and to create the app’s REST API and HTTP routes. 



The rest of the code defines these methods. It is not super important that you understand these methods in detail at this point, but we are briefly explaining them below to give you an idea.

**config() method** 
The config method configures some aspects of our Express Web server:

- it tells the Web server where to find public documents (in the “public” directory),
- it configures a template based view engine (Pug) that can be used to generate HTML pages (this will be explained later in this lab),
- it mounts a logging engine, components to parse JSON, encoded URLs and Web cookies.
- it registers a function to catch 404 (resource not found) errors and registers the error handler.

The above is done by registering so-called middleware functions with the Express Web framework. You can read [this](https://medium.com/@agoiabeladeyemi/a-simple-explanation-of-express-middleware-c68ea839f498) introduction to get an idea of what goes on here.

**routes() method**
The routes method sets up the routes in our application (the URL paths in our Web app). Our boilerplate code uses one class called IndexRoute to define the routes. (more about this later).


## Step 3: Get our Server class to compile

After pasting the above boilerplate code into the app.ts file, you will likely notice a set of compiler errors. Some of them may be related to missing “type declaration files” (see TS7016 below). Others may be related to missing modules. Let’s understand and resolve them.

![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533327392078_image.png)


Errors related to missing “declaration files” originate from the aforementioned fact that TypeScript is a type-safe language. The compiler wants to check that the code you write is typed correctly. However, since we are using JavaScript libraries (which are untyped), the compiler cannot do so. Fortunately, the [type declaration files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html) are available for import on all common JavaScript libraries. They can be installed using the node package manager (npm). Open a terminal (command prompt) in your project directory and enter the following command to install the missing type definition file for the *body-parser* module, for example:

`npm install @types/body-parser`

When you click on the app.ts file in WebStorm, you should see the related error message disappear. Go ahead and install the other type definition files. 
Note that some of these commands need to be enforced using the —save operation in your terminal as commented on the side when **npm 1 error** pops up on your screen: 

`npm install @types/cookie-parser`
`npm install @types/express`
`npm install @types/morgan` 

In the above example, the errorhandler module is still missing. Go ahead and install it.

`npm install` `@types/``errorhandler`

And of course the type definition for that library module. (You know how.)

We have one more error to resolve. The TypeScript compiler cannot find the module “routes”. That’s of course true, since we have not yet defined any routes. (Indeed the “express-generator” script has generated some default routes in the “routes” directory, but they are defined in JavaScript - and we are programming in TypeScript.) So, let’s delete the generated JavaScript files in the “routes” directory (index.js and users.js). (This time the IDE does not warn about any usages of the deleted files, since they are not used.)


## Step 4: Define some routes

We want all our TypeScript source code in the src directory, so let’s move the routes directory there. (Simple drag and drop in the WebStorm project browser.)

As mentioned earlier, routes are defined as TypeScript classes. Since our application will likely have many different routes, it makes sense to define one *BaseRoute* superclass to implement any functions and house any data common to all other routes. Therefore, let’s create such a *BaseRoute* in a new TypeScript file called “route” in the *routes* directory. Then copy [this](https://paper.dropbox.com/doc/Boilerplate-code-for-routes.ts--ALXnO0vi9wNKq9SUhnwgjV1cAg-5FoLDEIE6uq372Y2gM3SN) boilerplate code into the new file.

As you can see, the code imports several classes from the *express* module, including “Request” and “Response”. It then defines a *BaseRoute* class with two fields: a title (for our Web page) and an array of scripts. The class has a *render* function that takes a request and response object, a view (string) and an optional parameter for additional options. The render function of the BaseRoute class does not do much. It sets some values of the response and then calls “render” of the response object with the given view and options.

![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533331434001_image.png)


Let’s now create another route, extending our BaseRoute. Let’s call the new TypeScript file (in the *routes* directory) “index” and copy [this](https://paper.dropbox.com/doc/Boilerplate-code-for-index--ALU0BGFtsQJwxQqr7LiTXStlAg-8h64niZ6TaUeTXwED2mZZ) boilerplate code. The code defines a new routing class *IndexRoute* extending BaseRoute. It therefore needs to import BaseRoute. 


![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533332842062_image.png)


IndexRoute defines a method “*index*”, which handles requests on this route. It does not do much, but defines a custom title and also an option object with a “message” field. (More about how this is used later.) It then calls the render function (inherited from BaseRoute), specifying that we want to view the “index” page (still needs to be created) and our option object.

IndexRoute also defines a static method *“create”* for registering the above handler function (index) with the Express router as a *GET* request (see below). (If you are unfamiliar with HTTP and the difference between GET, POST and other HTTP methods, have a look [here](https://www.w3schools.com/tags/ref_httpmethods.asp). 

![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533333042337_image.png)


The syntax of the expression registering the handler with the Express router may appear confusing and complex, if you are new to TypeScript. What we would normally expect here is something like:
`router.get("/", new IndexRoute().index())` or similar.

First of all, recall from Lab 1 that the greyed “path:” and “handlers:” annotation in the above screenshot are not part of the TypeScript language, but they are merely *displayed* by the WebStorm IDE to help you understand what the expected parameters of the function call to “get” are. (You can’t actually edit them.)

Secondly, we need to understand that the Express (JavaScript) framework expects JavaScript *functions* to be registered as handlers. We therefore have to define a function that delegates its functionality to the *index* method of an IndexRoute object. TypeScript (and ES6) has the  `=>` (called “fat arrow”) notation to define a function. For example, you can define a function *add* to add up two numbers:


    let add = (a,b) => a + b;

This is a short hand to the following equivalent definition:


    let add = function(a,b) {
            return a + b;
    };

This and the fact that TypeScript requires types to be defined should explain the above expression.


## Step 5: Fixing the Node start-up script

So far, so good. If everything went according to plan, the IDE should no longer show any errors for our TypeScript classes. (You may have to refresh the window showing our *app.ts* file for the IDE to register that the *route* module is now present.)


![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533335321626_image.png)


We still need to tidy up our Node startup script. **Firstly**, remember our Node startup script (*www*) in the *bin* directory, which now needs to load the JavaScript app generated by the tlc compiler from our TypeScript source code. If things worked according to plan, you should have an app.js JavaScript file generated in the *dist* folder. (Remember that we deleted the app.js file that was generated by the express-generator script in Step 1 (above). So let’s edit the www script to provide it with the right location for the generated app.js file (../dist/app).

**Secondly**, we need to make a change to our startup script based on the fact that we have programmed our app in a TypeScript class: We need to call the bootstrap method of our server class. Modify the startup (www) script accordingly (see the two images below).


![Old www script](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533338521021_image.png)



![modified www script](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533338770247_image.png)



## Step 6: Create some HTML views

We have not defined any HTML views yet. Actually, you will see that the express-generator has already generated a few boilerplate files under a directory called “*views*”. These are not HTML files but *pug* files.  As mentioned in the introduction, [pug](https://pugjs.org/api/getting-started.html) is a templating library for generating HTML. 


![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533335895315_image.png)


Let’s have a look inside and open the “layout.pug”. You see that pug makes writing HTML structures much easier and also allows us to include variables defined in our app. Pug views can also “extend” each other. For example, the (autogenerated) *index* and 

![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533336261602_image.png)


*error* views extend the generic layout view. That way we can put common layout structures in base views and simply inherit them in more specific views. We will not give a detailed tutorial to pug in this lab. Explore and learn on your own. 🙂 

When you open a pug file the first time with WebStorm, the IDE will offer to automatically compile the Pug files to HTML. Click “no”. The Express engine will take care of this for us. (Remember that we registered “pug” as the view engine in the config method of our Server class (file app.ts).

![Excerpt from our app.ts file](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533336512487_image.png)


The only thing we need to change is the directory that is configured to find the Pug files. (Keep in mind that the TypeScript file app.ts is compiled into a JavaScript file app.js in the “dist” directory.) Therefore, we need to change the directory configured for the views from “views” (above) to “../views”. ex


## Step 7: Start the app

If everything went according to plan, you should be ready to start the app. Simply click on *Run/Run ‘bin/www’* in the WebStorm menu bar and you should see that your Web server is running on port 3000.

![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533339485295_image.png)


You can open a browser and navigate to that port (on localhost) and you should see our index page rendered.

![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533339549073_image.png)


You can also automate starting up a browser by adding this task to the ‘bin/www’ Run/Debug configuration in WebStorm.

![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533339709413_image.png)


Open the *index.pug* and *index.ts* file again and observe how the “title” variable has been used in the generation of the final view of this page. Go ahead and experiment. Try to modify the index view (index.pug) to also display the “message” defined in the *index* function of the index route (index.ts).

Change the pug file and refresh the browser. You will see the change immediately. Now change the value of the “title” variable in index.ts and refresh the browser. Do you see any changes? Why not?

The reason is that the index handler function is registered with the Node server during server start up. You would have to restart the server to see changes made in your TypeScript program. Luckily, there is also a tool that is capable of watching your source code for changes and restarting the node server automatically. That tool is called nodemon and can be installed with “npm install -g nodemon”. (Should be installed in the labs.)

You can add nodemon to your Run/Debug Configuration in Webstorm by adding the path to the nodemon executable to the “Node parameters” field:

![](https://d2mxuefqeaa7sj.cloudfront.net/s_DEA23312359A018B99122761C59E14AFD4DE7DDD3B52927724B3F93A8B6ADCAF_1533343229183_image.png)


You should now find that the Node web server restarts automatically nodemon detects any changes to your source code. Go ahead and try changing the message in the index handler again and refresh your browser.


## Summary 

We learned how to set up a basic Web application with TypeScript, Node, WebStorm, Express and Pug. Go ahead and experiment and continue learning about these technologies.

*Note: Writing the UI for Web applications with server-side generated HTML (for example with HTML generated by Pug) is the “old” way of writing Web applications. In this old style, most computation happens on the server and the browser communicates to the server each time the view needs to change. Today’s modern Web applications have a fair amount of client-side code, to provide a more dynamic UI. We will cover this in Lab 4.*

